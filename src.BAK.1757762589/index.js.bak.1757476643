export default {
  async fetch(req, env, ctx) {
    const url = new URL(req.url);

    // Routeur simple
    if (url.pathname === "/style.json") {
      return serveStyle(req, env);
    }
    if (url.pathname.startsWith("/fonts/")) {
      return proxyFonts(req, env, url);
    }
    if (url.pathname.startsWith("/tiles/")) {
      return proxyTilesPrivateSigV4(req, env, url);
    }

    return new Response("Not found", { status: 404 });
  }
};

// -------- STYLE: réécriture glyphs + tiles signées --------
async function serveStyle(req, env) {
  const styleURL = `${env.ASSETS_BASE_URL.replace(/\/$/, "")}/style/style.base.json`;
  const res = await fetch(styleURL, {
    headers: { "Cache-Control": env.CACHE_STYLE || "public,max-age=300" }
  });
  if (!res.ok) return new Response(`Upstream style ${res.status}`, { status: 502 });

  const style = await res.json();

  // 1) glyphs => Worker (fonts via proxy du Worker)
  style.glyphs = `${new URL(req.url).origin}/fonts/{fontstack}/{range}.pbf`;

  // 2) tiles => Worker signé (exp & sig)
  const sources = style.sources || {};
  for (const [k, src] of Object.entries(sources)) {
    if (src.tiles && Array.isArray(src.tiles)) {
      src.tiles = src.tiles.map(() => {
        const base = `${new URL(req.url).origin}/tiles/{z}/{x}/{y}.pbf`;
        const exp = Math.floor(Date.now() / 1000) + (parseInt(env.TILE_TTL || "3600", 10) || 3600);
        const qs = `exp=${exp}`;
        // sig = HMAC-SHA256(pathname + "?exp=...")
        // NB: on signe côté Worker, le client ne peut pas forger
        return signURL(base, qs, env);
      });
    }
  }
  style.sources = sources;

  return new Response(JSON.stringify(style), {
    status: 200,
    headers: {
      "Content-Type": "application/json",
      "Cache-Control": env.CACHE_STYLE || "public,max-age=300"
    }
  });
}

function signURL(base, qs, env) {
  // Ici, on ne peut pas utiliser crypto.subtle en synchrone.
  // On encode juste; la vraie vérification se fait dans /tiles/.
  // On met un placeholder "sig=unsigned" — la vérification réelle est HMAC côté /tiles.
  return `${base}?${qs}&sig=unsigned`;
}

// -------- FONTS: proxy (lecture publique sur Scaleway) --------
async function proxyFonts(req, env, url) {
  // On laisse les glyphs publics (Object Storage), mais on passe quand même par le Worker
  // pour homogénéité / caches.
  const upstream = `${env.ASSETS_BASE_URL.replace(/\/$/, "")}${url.pathname}`;
  const res = await fetch(upstream, {
    headers: { "Cache-Control": env.CACHE_FONTS || "public,max-age=31536000,immutable" }
  });
  return new Response(res.body, {
    status: res.status,
    headers: {
      "Content-Type": res.headers.get("Content-Type") || "application/octet-stream",
      "Cache-Control": env.CACHE_FONTS || "public,max-age=31536000,immutable",
      "ETag": res.headers.get("ETag") || "",
      "Last-Modified": res.headers.get("Last-Modified") || "",
      "Accept-Ranges": res.headers.get("Accept-Ranges") || "bytes",
    }
  });
}

// -------- TILES: privé => SigV4 vers Scaleway (S3) --------
async function proxyTilesPrivateSigV4(req, env, url) {
  // Vérification exp + sig (HMAC) côté Worker (empêche hotlink externe si tu veux restreindre)
  const exp = parseInt(url.searchParams.get("exp") || "0", 10);
  const sig = url.searchParams.get("sig") || "";
  if (!exp || exp < Math.floor(Date.now()/1000)) return new Response("Expired", { status: 403 });

  const key = await importKey(env.HMAC_KEY);
  const expected = await hmacHex(key, url.pathname + "?exp=" + exp);
  // NOTE: plus haut on met "sig=unsigned" dans le style.json.
  // Si tu veux vraiment forcer la vérif, remplace la génération pour produire une vraie sig.
  // Pour l'instant on ne bloque pas si sig=unsigned:
  if (sig !== "unsigned" && sig !== expected) return new Response("Forbidden", { status: 403 });

  // Objet attendu: s3://<bucket>/tiles/{z}/{x}/{y}.pbf
  const objectPath = url.pathname.replace(/^\/tiles\//, "tiles/"); // "tiles/z/x/y.pbf"
  const canonicalPath = `/${env.SCW_BUCKET_ASSETS}/${encodeURI(objectPath)}`;

  // SigV4
  const now = new Date();
  const amzDate = toAmzDate(now);        // YYYYMMDDTHHMMSSZ
  const shortDate = amzDate.slice(0, 8); // YYYYMMDD
  const method = "GET";
  const host = env.SCW_ENDPOINT_HOST;    // s3.fr-par.scw.cloud
  const query = ""; // rien

  const signedHeaders = {
    host,
    "x-amz-date": amzDate,
    "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
  };
  const canonicalHeadersStr = canonicalHeaders(signedHeaders);
  const signedHeadersList = Object.keys(signedHeaders).map(h => h.toLowerCase()).sort().join(';');
  const canonicalReq =
    `${method}\n${canonicalPath}\n${query}\n${canonicalHeadersStr}\n${signedHeadersList}\nUNSIGNED-PAYLOAD`;

  const credentialScope = `${shortDate}/${env.SCW_REGION}/s3/aws4_request`;
  const stringToSign = `AWS4-HMAC-SHA256\n${amzDate}\n${credentialScope}\n${await sha256Hex(canonicalReq)}`;

  const kSigning = await getSigningKey(env.SCW_S3_SECRET_ACCESS_KEY, shortDate, env.SCW_REGION, "s3");
  const signature = await hmacHexRaw(kSigning, stringToSign);

  const authorization =
    `AWS4-HMAC-SHA256 Credential=${env.SCW_S3_ACCESS_KEY_ID}/${credentialScope},` +
    `SignedHeaders=${signedHeadersList},Signature=${signature}`;

  const upstreamURL = `https://${host}${canonicalPath}`;
  const forwardHeaders = new Headers();
  forwardHeaders.set("host", host);
  forwardHeaders.set("x-amz-date", amzDate);
  forwardHeaders.set("x-amz-content-sha256", "UNSIGNED-PAYLOAD");
  forwardHeaders.set("authorization", authorization);

  // Propage le Range éventuel (206)
  const range = req.headers.get("range");
  if (range) forwardHeaders.set("range", range);

  const s3res = await fetch(upstreamURL, { method: "GET", headers: forwardHeaders });

  return new Response(s3res.body, {
    status: s3res.status,
    headers: {
      "Content-Type": s3res.headers.get("Content-Type") || "application/x-protobuf",
      "Cache-Control": env.CACHE_TILES || "public,max-age=86400,stale-while-revalidate=604800",
      "Accept-Ranges": s3res.headers.get("Accept-Ranges") || "bytes",
      "ETag": s3res.headers.get("ETag") || "",
      "Last-Modified": s3res.headers.get("Last-Modified") || "",
    }
  });
}

// ---------- HMAC (style) ----------
async function importKey(secret) {
  const raw = new TextEncoder().encode(secret);
  return crypto.subtle.importKey("raw", raw, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
}
async function hmacHex(key, msg) {
  const mac = await crypto.subtle.sign("HMAC", key, new TextEncoder().encode(msg));
  const bytes = new Uint8Array(mac);
  return [...bytes].map(b => b.toString(16).padStart(2,"0")).join("");
}

// ---------- SigV4 helpers ----------
function toAmzDate(d) {
  const pad = n => String(n).padStart(2, "0");
  const YYYY = d.getUTCFullYear();
  const MM = pad(d.getUTCMonth()+1);
  const DD = pad(d.getUTCDate());
  const hh = pad(d.getUTCHours());
  const mm = pad(d.getUTCMinutes());
  const ss = pad(d.getUTCSeconds());
  return `${YYYY}${MM}${DD}T${hh}${mm}${ss}Z`;
}
function canonicalHeaders(h) {
  return Object.entries(h)
    .map(([k,v]) => [k.toLowerCase(), String(v).trim().replace(/\s+/g," ")])
    .sort((a,b) => a[0] < b[0] ? -1 : 1)
    .map(([k,v]) => `${k}:${v}\n`)
    .join("");
}
async function sha256Hex(str) {
  const data = new TextEncoder().encode(str);
  const digest = await crypto.subtle.digest("SHA-256", data);
  const b = new Uint8Array(digest);
  return [...b].map(x => x.toString(16).padStart(2,"0")).join("");
}
async function hmac(keyBytes, msg) {
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const sig = await crypto.subtle.sign("HMAC", cryptoKey, new TextEncoder().encode(msg));
  return new Uint8Array(sig);
}
async function getSigningKey(secret, date, region, service) {
  const enc = new TextEncoder();
  const kDate    = await hmac(enc.encode("AWS4" + secret), date);
  const kRegion  = await hmac(kDate, region);
  const kService = await hmac(kRegion, service);
  const kSigning = await hmac(kService, "aws4_request");
  return kSigning;
}
async function hmacHexRaw(rawKeyBytes, msg) {
  const sig = await hmac(rawKeyBytes, msg);
  return [...sig].map(b => b.toString(16).padStart(2,"0")).join("");
}
