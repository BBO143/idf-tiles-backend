import { fetchS3Private } from "./s3-presign.js";

const ONE_DAY = 86400;
const ONE_WEEK = 7 * ONE_DAY;
const ONE_YEAR = 31536000;

function setBinaryHeaders(h, cacheControl) {
  h.set("Content-Type", "application/x-protobuf");
  h.set("Cache-Control", `${cacheControl}, no-transform`);
  h.set("Vary", "Accept-Encoding");
  h.set("Access-Control-Allow-Origin", "*");  if (!h.has("Accept-Ranges")) h.set("Accept-Ranges", "bytes");
  const enc = h.get("Content-Encoding");
  if (enc && enc.toLowerCase() !== "gzip") {
    h.delete("Content-Encoding");
    h.delete("Content-Length");
  }
}
function setJsonHeaders(h, cacheControl) {
  h.set("Content-Type", "application/json; charset=utf-8");
  h.set("Cache-Control", `${cacheControl}, no-transform`);
  h.set("Vary", "Accept-Encoding");
  h.set("Access-Control-Allow-Origin", "*");}
function normalizeBinaryResponse(originRes, cacheControl) {
  const h = new Headers(originRes.headers);
  setBinaryHeaders(h, cacheControl);
  h.set('Server-Timing', 'cf-no-br;desc="no brotli for protobuf"');
  return new Response(originRes.body, { status: originRes.status, statusText: originRes.statusText, headers: h });
}
function normalizeJsonResponse(originRes, cacheControl) {
  const h = new Headers(originRes.headers);
  setJsonHeaders(h, cacheControl);
  h.set('Server-Timing', 'cf-no-br;desc="no brotli for protobuf"');
  return new Response(originRes.body, { status: originRes.status, statusText: originRes.statusText, headers: h });
}
function kindFromPath(p) {
  if (p === "/style.json") return "style";
  if (p.startsWith("/tiles/") && p.endsWith(".pbf")) return "tiles";
  if (p.startsWith("/fonts/") && p.endsWith(".pbf")) return "fonts";
  return "other";
}
async function fetchPrivate(env, path, req) {
  const fwd = new Headers();
  for (const [k, v] of req.headers) {
    const lk = k.toLowerCase();
    if (lk === "range" || lk.startsWith("if-")) fwd.set(k, v);
  }
  fwd.set("Accept-Encoding", "identity");
  return fetchS3Private(env.ORIGIN_BASE_PRIVATE, path, env, fwd);
}
export default {
  async fetch(req, env) {
    const url = new URL(req.url);
    const p = url.pathname;
    const kind = kindFromPath(p);
    if (kind === "other") return new Response("Not Found", { status: 404 });
    if (!env.ORIGIN_BASE_PRIVATE) return new Response("Missing ORIGIN_BASE_PRIVATE", { status: 500 });

    if (kind === "style") {
      const up = await fetchPrivate(env, "/style.json", req);
      return normalizeJsonResponse(up, "public, max-age=300");
    }
    if (kind === "tiles") {
      const up = await fetchPrivate(env, p, req);
      return normalizeBinaryResponse(up, `public, max-age=${ONE_DAY}, stale-while-revalidate=${ONE_WEEK}`);
    }
    if (kind === "fonts") {
      const up = await fetchPrivate(env, p, req);
      return normalizeBinaryResponse(up, `public, max-age=${ONE_YEAR}, immutable`);
    }
    return new Response("Not Found", { status: 404 });
  },
};
